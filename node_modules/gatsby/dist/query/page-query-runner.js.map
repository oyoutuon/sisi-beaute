{"version":3,"sources":["../../src/query/page-query-runner.js"],"names":["_","require","Queue","convertHrtime","store","emitter","queryQueue","queuedDirtyActions","runQueriesForPathnamesQueue","Set","queueQueryForPathname","pathname","add","calcQueries","initial","uniq","a","payload","id","dirtyIds","findDirtyIds","cleanIds","findIdsWithoutDataDependencies","pathnamesToRun","diffedPathnames","intersection","union","clear","on","action","push","seenIdsWithoutDataDependencies","filter","p","path","state","getState","allTrackedIds","flatten","concat","values","componentDataDependencies","nodes","connections","notTrackedIds","difference","Array","from","pages","staticQueryComponents","map","c","jsonName","makeQueryJobs","pathnames","staticQueries","slice","pageQueries","queryJobs","forEach","staticQueryComponent","get","queryJob","hash","query","componentPath","context","page","components","isPage","actions","uniqDirties","reduce","node","internal","type","compact","runInitialQueries","activity","length","queue","makeBuild","startQueries","process","hrtime","stats","getStats","setStatus","total","peak","seconds","toFixed","processBatch","listenerQueue","runQueuedQueries","startListening","callback","then","catch","module","exports"],"mappings":"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","sourcesContent":["// @flow\n\nimport type { QueryJob } from \"../query-runner\"\nconst _ = require(`lodash`)\nconst Queue = require(`better-queue`)\nconst convertHrtime = require(`convert-hrtime`)\nconst { store, emitter } = require(`../redux`)\nconst queryQueue = require(`./queue`)\n\nlet queuedDirtyActions = []\n\nconst runQueriesForPathnamesQueue = new Set()\nconst queueQueryForPathname = pathname => {\n  runQueriesForPathnamesQueue.add(pathname)\n}\n\nconst calcQueries = (initial = false) => {\n  // Find paths dependent on dirty nodes\n  queuedDirtyActions = _.uniq(queuedDirtyActions, a => a.payload.id)\n  const dirtyIds = findDirtyIds(queuedDirtyActions)\n  queuedDirtyActions = []\n\n  // Find ids without data dependencies (i.e. no queries have been run for\n  // them before) and run them.\n  const cleanIds = findIdsWithoutDataDependencies()\n\n  // Construct paths for all queries to run\n  let pathnamesToRun = _.uniq([...dirtyIds, ...cleanIds])\n\n  // If this is the initial run, remove pathnames from `runQueriesForPathnamesQueue`\n  // if they're also not in the dirtyIds or cleanIds.\n  //\n  // We do this because the page component reducer/machine always\n  // adds pages to runQueriesForPathnamesQueue but during bootstrap\n  // we may not want to run those page queries if their data hasn't\n  // changed since the last time we ran Gatsby.\n  let diffedPathnames = [...runQueriesForPathnamesQueue]\n  if (initial) {\n    diffedPathnames = _.intersection(\n      [...runQueriesForPathnamesQueue],\n      pathnamesToRun\n    )\n  }\n\n  // Combine.\n  pathnamesToRun = _.union(diffedPathnames, pathnamesToRun)\n\n  runQueriesForPathnamesQueue.clear()\n\n  return pathnamesToRun\n}\n\nemitter.on(`CREATE_NODE`, action => {\n  queuedDirtyActions.push(action)\n})\n\nemitter.on(`DELETE_NODE`, action => {\n  queuedDirtyActions.push({ payload: action.payload })\n})\n\nlet seenIdsWithoutDataDependencies = []\n\n// Remove pages from seenIdsWithoutDataDependencies when they're deleted\n// so their query will be run again if they're created again.\nemitter.on(`DELETE_PAGE`, action => {\n  seenIdsWithoutDataDependencies = seenIdsWithoutDataDependencies.filter(\n    p => p !== action.payload.path\n  )\n})\n\nconst findIdsWithoutDataDependencies = () => {\n  const state = store.getState()\n  const allTrackedIds = _.uniq(\n    _.flatten(\n      _.concat(\n        _.values(state.componentDataDependencies.nodes),\n        _.values(state.componentDataDependencies.connections)\n      )\n    )\n  )\n\n  // Get list of paths not already tracked and run the queries for these\n  // paths.\n  const notTrackedIds = _.difference(\n    [\n      ...Array.from(state.pages.values(), p => p.path),\n      ...[...state.staticQueryComponents.values()].map(c => c.jsonName),\n    ],\n    [...allTrackedIds, ...seenIdsWithoutDataDependencies]\n  )\n\n  // Add new IDs to our seen array so we don't keep trying to run queries for them.\n  // Pages without queries can't be tracked.\n  seenIdsWithoutDataDependencies = _.uniq([\n    ...notTrackedIds,\n    ...seenIdsWithoutDataDependencies,\n  ])\n\n  return notTrackedIds\n}\n\nconst makeQueryJobs = pathnames => {\n  const staticQueries = pathnames.filter(p => p.slice(0, 4) === `sq--`)\n  const pageQueries = pathnames.filter(p => p.slice(0, 4) !== `sq--`)\n  const state = store.getState()\n  const queryJobs = []\n\n  staticQueries.forEach(id => {\n    const staticQueryComponent = store.getState().staticQueryComponents.get(id)\n    const queryJob: QueryJob = {\n      id: staticQueryComponent.hash,\n      hash: staticQueryComponent.hash,\n      jsonName: staticQueryComponent.jsonName,\n      query: staticQueryComponent.query,\n      componentPath: staticQueryComponent.componentPath,\n      context: { path: staticQueryComponent.jsonName },\n    }\n    queryJobs.push(queryJob)\n  })\n\n  const pages = state.pages\n  pageQueries.forEach(id => {\n    const page = pages.get(id)\n    if (page) {\n      queryJobs.push(\n        ({\n          id: page.path,\n          jsonName: page.jsonName,\n          query: store.getState().components.get(page.componentPath).query,\n          isPage: true,\n          componentPath: page.componentPath,\n          context: {\n            ...page,\n            ...page.context,\n          },\n        }: QueryJob)\n      )\n    }\n  })\n  return queryJobs\n}\n\nconst findDirtyIds = actions => {\n  const state = store.getState()\n  const uniqDirties = _.uniq(\n    actions.reduce((dirtyIds, action) => {\n      const node = action.payload\n\n      if (!node || !node.id || !node.internal.type) return dirtyIds\n\n      // Find components that depend on this node so are now dirty.\n      dirtyIds = dirtyIds.concat(state.componentDataDependencies.nodes[node.id])\n\n      // Find connections that depend on this node so are now invalid.\n      dirtyIds = dirtyIds.concat(\n        state.componentDataDependencies.connections[node.internal.type]\n      )\n\n      return _.compact(dirtyIds)\n    }, [])\n  )\n  return uniqDirties\n}\n\nconst runInitialQueries = async activity => {\n  const pathnamesToRun = calcQueries(true)\n  if (pathnamesToRun.length === 0) {\n    return\n  }\n\n  const queryJobs = makeQueryJobs(pathnamesToRun)\n\n  const queue = queryQueue.makeBuild()\n\n  const startQueries = process.hrtime()\n  queue.on(`task_finish`, () => {\n    const stats = queue.getStats()\n    activity.setStatus(\n      `${stats.total}/${stats.peak} ${(\n        stats.total / convertHrtime(process.hrtime(startQueries)).seconds\n      ).toFixed(2)} queries/second`\n    )\n  })\n  await queryQueue.processBatch(queue, queryJobs)\n}\n\n/////////////////////////////////////////////////////////////////////\n// Listener for gatsby develop\n\n// Initialized via `startListening`\nlet listenerQueue\n\n/**\n * Run any dirty queries. See `calcQueries` for what constitutes a\n * dirty query\n */\nconst runQueuedQueries = () => {\n  if (listenerQueue) {\n    listenerQueue.push(makeQueryJobs(calcQueries(false)))\n  }\n}\n\n/**\n * Starts a background process that processes any dirty queries\n * whenever one of the following occurs:\n *\n * 1. A node has changed (but only after the api call has finished\n * running)\n * 2. A component query (e.g by editing a React Component) has\n * changed\n *\n * For what constitutes a dirty query, see `calcQueries`\n */\nconst startListening = queue => {\n  // We use a queue to process batches of queries so that they are\n  // processed consecutively\n  listenerQueue = new Queue((queryJobs, callback) =>\n    queryQueue\n      .processBatch(queue, queryJobs)\n      .then(() => callback(null))\n      .catch(callback)\n  )\n\n  emitter.on(`API_RUNNING_QUEUE_EMPTY`, runQueuedQueries)\n}\n\nmodule.exports = {\n  runInitialQueries,\n  startListening,\n  runQueuedQueries,\n  queueQueryForPathname,\n}\n"],"file":"page-query-runner.js"}